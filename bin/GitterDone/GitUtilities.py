"""A module handling a lot of the common git specific operations will be using.

Attributes:
    GITIGNORE_FILENAME (str): default name of the file used to create the git
        ignore tree.
    GITIGNORE_BEGIN_TOKEN (str): A token to prefix to the output of the
        ignore file.
    GITIGNORE_END_TOKEN (str): A token to sufix to the output of the
        ignore file.

"""
import logging
import os
import fnmatch
import re
import sys

from . import Config as config
from . import ConsoleUtilities as console_utility
from . import ExternalProcessUtility as external_process
from . import FileUtilities as file_utility
from . import StringUtilities as str_utility

# ============================================================================
# Global Variables.
GITIGNORE_FILENAME = config.get_git_ignore_filename()
GITIGNORE_BEGIN_TOKEN = '# GENERATED BY GitterDone.py **********************\n'
GITIGNORE_END_TOKEN = '# END GEN ******************************************\n'
# ============================================================================


# ============================================================================
class Node:  # pylint:disable=R0903
    """
    Object representation of each entry in a tree.

    Attributes:
        path (string): String representing a filepath.
        is_leaf (bool): Flag representing if this node is a leaf.

    """

    def __init__(self, path, is_leaf):
        """
        Object constructor.

        Args:
            path (string): String representing a filepath.
            is_leaf (bool): Flag representing if this node is a leaf.

        """
        self.path = path
        self.is_leaf = is_leaf
# ============================================================================


# ============================================================================
def generate_git_ignore(to_track: list,
                        to_ignore: list,
                        ignore_file_path: str = '.'):
    """
    Handle creating the new gitignore that just tracks everything by default.

    Args:
        to_track (list): The list of files and folders to be tracked.
        to_ignore (list): The list patterns to be ignored by git.
        ignore_file_path (str): The absolute path to the desired git ignore.

    """
    logging.info("Automatically Generating the %s file.", GITIGNORE_FILENAME)

    file_contents = []
    wish_list = to_track

    wish_list = str_utility.normalize_strings(wish_list)
    ignore_patterns_list = str_utility.normalize_strings(to_ignore)
    ignore_regex_list = str_utility.convert_to_regex_entries(
        ignore_patterns_list
        )
    logging.debug('Tracking the following patterns: %s',
                  str_utility.friendly_list_to_str(wish_list))
    logging.debug('Ignoring the following patterns: %s',
                  str_utility.friendly_list_to_str(ignore_patterns_list))

    wishlist_file_map = file_utility.generate_wishlist_filemap(wish_list)

    final_ignore_list = file_utility.recursely_get_ignored(".",
                                                           [],
                                                           wishlist_file_map,
                                                           ignore_regex_list)

    final_ignore_list.sort()
    file_contents.append(GITIGNORE_BEGIN_TOKEN)
    file_contents.append('\n')
    file_contents.append("# --- Ignored patterns imported from config.\n\n")
    for item in ignore_patterns_list:
        file_contents.append(item + '\n')
    file_contents.append("\n# --- Auto Generated to be ignored.\n\n")
    for item in final_ignore_list:
        if sys.platform == 'win32':
            path = os.altsep + item + '\n'
        else:
            path = os.sep + item + '\n'
        file_contents.append(path)
    file_contents.append('\n')
    file_contents.append(GITIGNORE_END_TOKEN)

    logging.debug("New gitignore contents:\n %s",
                  file_contents)
    _save_git_ignore_to_disk(file_contents, ignore_file_path)

    logging.info('%s was updated successfully!', GITIGNORE_FILENAME)


def _save_git_ignore_to_disk(contents: str, filepath: str):
    """
    Save the .gitignore file to disk.

    Args:
        contents (str): Contents of the file to be written.

    """
    output_path = '.'
    if os.path.isdir(filepath):
        output_path = os.path.join(filepath, GITIGNORE_FILENAME)
    else:
        output_path = GITIGNORE_FILENAME
    logging.info('Saving ignore list to disk at \"%s\".', output_path)
    logging.debug('Contents of ignore file: \n%s', contents)

    file = open(output_path, 'w')
    file.writelines(contents)

    file.close()


def _remove_ignored_files_from_file_list(file_list: list, ignore_list: list):
    pruned_file_list = file_list

    # based on the ignore rules, remove some files from the files_list
    for path in ignore_list:

        # reset the list
        items_to_exclude = []

        # is there a * in the rule?
        if path.find('*') != -1:
            # yes! there is a * in the rule
            # try fnmatch
            items_to_exclude = fnmatch.filter(pruned_file_list, path)

        else:
            # no! there is no * in the rule
            # try regular string comparison
            for i in pruned_file_list:
                if i.find(path) != -1:
                    items_to_exclude.append(i)

        for i in items_to_exclude:
            pruned_file_list.remove(i)

    return pruned_file_list

# ============================================================================


# ============================================================================
# Git Log file parsing operations.
def get_modified_files_for_branch(
        desired_branch: str,
        include_trunk_branch: str,
        trunk_branch_name: str,
        ignored_branches: str = ""):
    """
    Query the git repository and extracts all the files touched by the user.

    Args:
        desired_branch (str): The branch to be pulled. If no branch is passed,
            it would return all files modified regardless of branch.
        include_trunk_branch (str): A flag representing whether we should also
            include the changes on the trunk branch.
        trunk_branch_name (str): The name of the main branch that we usually
            ignore because it brings changes from the main source control
            solution.
        ignored_branches (str, optional): A string containing a group of
            branches that should be ignored separated by spaces.

    Returns:
        list: A list of all the files modified that exist in the local folder
            structure.

    """
    command = ''

    if desired_branch:
        logging.info('Getting all the commits for branch: %s', desired_branch)
        if include_trunk_branch:
            logging.info(('Include %s changes in result'
                          ' requested for branch: %s'),
                         trunk_branch_name,
                         desired_branch)

            command = (f'git log {desired_branch}'
                       ' --name-status --oneline --no-merges')
        else:
            command = (f'git log {desired_branch} --name-status '
                       f'--oneline --no-merges --not '
                       f'{trunk_branch_name} {ignored_branches}')
    else:
        logging.info('Getting all the commits for the entire repository')
        if include_trunk_branch:
            logging.info('Include the trunk branch changes requested')
            command = 'git log --all --name-status --oneline --no-merges'
        else:
            command = (f'git log --all --name-status'
                       f' --oneline--no-merges'
                       f' --not {trunk_branch_name} {ignored_branches}')

    successfull_command_call, \
        command_results = external_process.trigger_external_subprocess(
            command)

    if successfull_command_call:
        return _parse_modified_files_list(command_results)

    return None, None


def _parse_modified_files_list(plain_text_input: str):
    """
    Parse a plain text return from a git log command.

    Based on the entry we bucket the output into the appropriate file list.
    'Add', 'Delete', 'Edit.'

    Args:
        plain_text_input (str): The plain text return from a git log command,
                                   informing which files have been touched.

    Returns:
        list: A lists of files that need to be added to P4.
        list: A lists of files that need to be removed from P4.

    """
    add_edit_list = []
    delete_list = []

    lines = plain_text_input.splitlines()

    # Reverse the list so we follow a chronological order. Important in special
    # cases e.g. A file is first deleted and then added again.
    lines.reverse()

    pretty_lines_list = str_utility.friendly_list_to_str(lines)
    logging.debug('Extracted logs from the git branch: %s', pretty_lines_list)

    for line in lines:
        logging.debug('Parsing the following line: \"%s\"', line)

        # look for: add (A), delete (D), modify (M)
        match = re.match(r'([ADM])\s*\t*(.+)', line)
        if match:
            if (match.group(1) == 'A' or match.group(1) == 'M'):
                logging.debug('File added or modified: \"%s\" \n',
                              match.group(2)
                              )
                _sync_file_lists(match.group(2), add_edit_list, delete_list)
                continue

            if match.group(1) == 'D':
                logging.debug('File to be deleted: \"%s\" \n', match.group(2))
                _sync_file_lists(match.group(2), delete_list, add_edit_list)
                continue

        # look for: rename (R)
        match = re.match(r'R[0-9]+\s*\t*(.+(?=\w*\s*\t))\s*\t*(.+)', line)
        if match:
            logging.debug(
                'File to be renamed from this \"%s\", to this \"%s\" \n',
                match.group(1), match.group(2)
                )

            _sync_file_lists(match.group(1), delete_list, add_edit_list)
            _sync_file_lists(match.group(2), add_edit_list, delete_list)
            continue

    delete_list_string = str_utility.friendly_list_to_str(delete_list)
    logging.debug('Files to be deleted: %s', delete_list_string)

    add_list_string = str_utility.friendly_list_to_str(add_edit_list)
    logging.debug('Files to add/edit: %s', add_list_string)

    return add_edit_list, delete_list


def _sync_file_lists(file, list_to_add_to, list_to_remove_from):
    """
    Keep the lists in sync.

    We remove files from the delete list and add to the other, checking if
    it doesn't exist already in that list. Allows us to handle Renames.

    Args:
        file (string): The file path that we want to add to "list_to_add_to".
        list_to_add_to (list): list where we want to add the file to.
        list_to_remove_from (list): list where we need to check for the
            presence of the file and remove it from there.

    """
    if file in list_to_remove_from:
        list_to_remove_from.remove(file)
    if file not in list_to_add_to:
        list_to_add_to.append(file)

# ============================================================================


# ============================================================================
# Git Operations.
def stage_git_changes():
    """
    Add all the changes in the current git branch.

    Returns:
        bool: True if the git add command was successful.

    """
    git_add_command = 'git add -A'
    git_status_command = 'git status'
    attempts = 0

    while attempts < 3:
        # first check if there are changes.
        successfull_command_call, \
            command_results = external_process.trigger_external_subprocess(
                git_status_command)
        if not successfull_command_call:
            logging.error('git status operation failed.')
            return False

        if 'Changes not staged for commit' in command_results:
            if attempts >= 2:
                logging.error(
                    ('Exceeded attempts to add local changes to git.'
                     ' Please address manually.')
                )
                return False

            logging.info(('Found more changes available to be staged.'
                          ' Triggering git add command once again.'))

            successfull_command_call, \
                command_results = external_process.trigger_external_subprocess(
                    git_add_command)
            if not successfull_command_call:
                logging.error('Could not perform git add operation.')
                return False

        elif 'nothing to commit, working tree clean' in command_results:
            logging.info('No changes found that need to be committed.')
            break
        attempts += 1
    return True


def commit_git_changes(commit_mesage):
    """
    Create a commit in git with the latest changes.

    Returns:
        bool: True if the git commit command was successful.

    """
    command = f'git commit -v -m \"{commit_mesage}\"'
    successfull_command_call,\
        command_results = external_process.trigger_external_subprocess(
            command)
    if successfull_command_call:
        logging.debug("Commit sucessfull:\n%s", command_results)
        return True
    return False


def git_fetch():
    """
    Fetch the last state of the git repository.

    Returns:
        bool: True if the operation successfully completes.

    """
    command = 'git fetch --all --tags --force --prune'
    successfull_command_call, \
        command_results = external_process.trigger_external_subprocess(
            command)
    if successfull_command_call:
        logging.debug("Fetch sucessfull:\n%s", command_results)
        return True
    return False


def discard_git_changes():
    """
    Discard all the changes in the current git branch via forced reset.

    Returns:
        bool: True if the discard was successful.

    """
    command = 'git reset --hard'
    successfull_command_call, \
        command_results = external_process.trigger_external_subprocess(
            command)
    if successfull_command_call:
        logging.debug("Reset sucessfull:\n%s", command_results)
        return True
    return False


def push(origin_name: str, tag: str = None, forced: bool = False):
    """
    Perform a Git Push Operation.

    Returns:
        bool: True if the push was successful.

    Args:
        origin_name (str): the name of the remote branch.
        tag (str, optional): a tag to push.
        forced (bool, optional): flag to check if we should push forcefully
             (DANGEROUS)

    """
    command = f'git push {origin_name}'
    if forced:
        command = f'git push -f {origin_name}'
    if tag is not None:
        command += f' {tag}'

    logging.debug(
        "Pushing to the respository via the following command: %s",
        command)
    successfull_command_call,\
        command_results = external_process.trigger_external_subprocess(
            command)
    if successfull_command_call:
        logging.debug("Push sucessfull:\n%s", command_results)
        return True
    return False


def tag_commit(tag: str,
               message: str = None,
               force: bool = False,
               commit_hash: str = None):
    """
    Tag the current commit in git.

    Args:
        tag (str): The tag to use.
        force (bool, optional): If we need to force the tag

    Returns:
        bool: A flag notifying the calling function if tagging the current
            commit was successful.

    """
    command = f'git tag {tag}'
    if force:
        command += ' -f'
    if message:
        command += f' -m "{message}"'
    if commit_hash is not None:
        command += f' {commit_hash}'

    logging.debug("Tagging commit via the following command: %s", command)
    successfull_command_call,\
        command_results = external_process.trigger_external_subprocess(
            command)
    if successfull_command_call:
        logging.debug("Tagged:\n %s", command_results)
        return True
    return False


def delete_tag(tag: str,
               delete_on_remote: bool = False,
               remote_name: str = None):
    """
    Tag the current commit in git.

    Args:
        tag (str): The tag to use.
        delete_on_remote (bool, optional): Flag to track if we want to delete
            it from the remote.
        remote_name (str, optional): The name of the remote.

    Returns:
        bool: A flag notifying the calling function if tagging the current
            commit was successful.

    """
    command = f'git tag --delete {tag}'
    if delete_on_remote:
        command += f' & git push -f {remote_name} :refs/tags/{tag}'

    logging.debug(
        "Deleting a tag from the respository via the following command: %s",
        command)
    successfull_command_call,\
        command_results = external_process.trigger_external_subprocess(
            command)
    if successfull_command_call:
        logging.debug("Tagged deleted:\n %s", command_results)
        return True
    return False


def check_and_resolve_pending_git_changes(bypass_prompt: bool = False):
    """
    Verify that the branch has no current pending changes.

    Returns:
        bool: True if the user resolved the pending changes on git.

    """
    logging.info("Checking for pending changes in current branch.")
    resolved_changes = False
    command = "git status -s"
    successfull_command_call,\
        command_results = external_process.trigger_external_subprocess(
            command)
    if successfull_command_call:
        if command_results:
            logging.error("There are pending changes on this branch!")

            discard_changes = False
            if not bypass_prompt:
                discard_changes = \
                    console_utility.request_user_input_with_choices(
                        "Would you like to discard the current changes?",
                        "y/n",
                        "y",
                        "n")

            if discard_changes or bypass_prompt:
                resolved_changes = discard_git_changes()
        else:
            resolved_changes = successfull_command_call
    return resolved_changes


def check_and_resolve_if_user_is_on_branch(branch_name: str,
                                           bypass_prompt: bool = False):
    """
    Check if the user is already on the right branch.

    Returns:
        bool: True if the user is on the right branch or resolved moving
            to the right git branch.

    """
    logging.info("Checking if the user is already on the trunk branch.")
    user_already_in_trunk_branch, current_branch = is_user_in_branch(
        branch_name)

    if not user_already_in_trunk_branch:
        if not current_branch:
            return False

        prompt_message = (f'You are currently on branch: \"{current_branch}\",'
                          ' Would you like to switch to \"{branch_name}\"?')

        forcefully_switch_branches = False

        if not bypass_prompt:
            forcefully_switch_branches =\
                console_utility.request_user_input_with_choices(
                    prompt_message,
                    'y/n',
                    'y',
                    'n')

        if forcefully_switch_branches or bypass_prompt:
            user_already_in_trunk_branch = checkout_branch(branch_name)
        else:
            logging.error(
                "User triggered interrupt due to cancelled branch switch.")
            return False

    return user_already_in_trunk_branch


def is_user_in_branch(branch_name: str):
    """
    Verify if the user is already on the Trunk Branch.

    Returns:
        bool: True if the user is already at the trunk branch.
        string: A string with the name of the current branch if the user is not
             on the right branch. Empty otherwise.

    """
    command = "git rev-parse --abbrev-ref HEAD"
    successfull_command_call,\
        command_results = external_process.trigger_external_subprocess(
            command)
    if successfull_command_call:
        match = re.match(r'(.+)', command_results)
        if match:
            if not match.group(0):
                logging.error(
                    "Did not receive a response to external process call: %s",
                    command)
                return False, ""
            if not match.group(0) == branch_name:
                logging.error(('Current branch \"%s\" is not the trunk branch.'
                               ' Prompt resolution.'),
                              match.group(0))

                return False, match.group(0)
        else:
            logging.fatal(
                "Could not determine current git branch. Terminating"
            )
            return False, ""
    return True, ""


def checkout_branch(branch_name: str):
    """
    Check out a branch.

    Returns:
        bool: True if the branch checkout was successful.

    """
    logging.info("Executing checkout of the trunk branch.")

    command = f"git checkout {branch_name} -f"

    successfull_command_call,\
        command_results = external_process.trigger_external_subprocess(
            command)
    if successfull_command_call:
        logging.info("Successfully checked out %s.", branch_name)
        logging.debug("Checkout Successful:\n%s", command_results)
        return True

    logging.error(
        "Could not successfully complete the git checkout of the trunk branch."
    )
    return False


def pull_latest_branch_version(branch_name: str, default_remote_name: str):
    """
    Perform a git pull request on the trunk git branch.

    Returns:
        bool: True if the pull request was successful.

    """
    logging.info("Pulling latest commit from remote forcefully in git.")

    command = "git reset --hard " + default_remote_name + "/" + branch_name
    successfull_command_call,\
        command_results = external_process.trigger_external_subprocess(
            command)
    if successfull_command_call:
        logging.info(
            "Successfully git pulled to latest commit in the trunk branch.")
        logging.debug("Pull results:\n%s", command_results)
        return True

    logging.error(
        "Could not complete a git pull to the latest trunk branch commit."
    )
    return False


def get_details_of_last_commit_for_tag(desired_tag_name: str):
    """
    Get the details from the commit matching that has the matching tag.

    Args:
        desired_tag_name (str): the tag name to check against the network.

    Returns:
        string: A string reflecting the last CL number. Empty if at the lastest

    """
    logging.info("Getting the details of the commit tagged as: %s",
                 desired_tag_name)

    command = "git log -1 --oneline " + desired_tag_name
    successfull_command_call,\
        command_results = external_process.trigger_external_subprocess(
            command)
    if successfull_command_call:
        logging.info("Successfully retrieved details of commit tagged as: %s",
                     desired_tag_name)
        return command_results

    logging.error("Git log command unsuccessful. Check your git installation.")
    return ""


def get_details_of_last_commit_for_branch(desired_branch_name: str):
    """
    Get the latest commit details from the last submission in the trunk branch.

    Args:
        desired_branch_name (str): the name of the desired branch to get the
            details from.

    Returns:
        str: A string reflecting the last CL number. Empty if already at the
            lastest version.

    """
    logging.info("Getting the details of the last commit in branch: %s",
                 desired_branch_name)
    available_git_brances = get_git_branch_information()

    branch_exists = verify_branch_exists_in_git(desired_branch_name,
                                                available_git_brances)
    if not branch_exists:
        logging.fatal("Branch: %s does not exist on your current repository.",
                      desired_branch_name)
        return ""

    command = "git log -1 --oneline " + desired_branch_name
    successfull_command_call,\
        command_results = external_process.trigger_external_subprocess(
            command)
    if successfull_command_call:
        logging.info(
            "Last commit details from branch: %s retrieved successfully",
            desired_branch_name
            )
        return command_results

    logging.error("Git log command unsuccessful. Check your git installation.")
    return ""


def parse_cl_number_from_raw_commit_message(raw_commit_message: str):
    """
    Parse the last commit number from the raw details of the git log call.

    Args:
        raw_commit_message (str): A string containing a raw commit message from
            a git log call.

    Returns:
        str: Isolated CL string if parsed correctly.

    """
    match = re.search(r'(?=CL (\d+))', raw_commit_message)
    if not match:
        if not match.group(1):
            logging.fatal(
                'The last commit does not follow convention: CL [Number].'
            )
        return ''

    return match.group(1)


def parse_hash_from_raw_commit_message(raw_commit_message: str):
    """
    Parse the commit hash from the raw details of the git log call.

    Args:
        raw_commit_message (str): A string containing a raw commit message from
             a git log call.

    Returns:
        str: Isolated hash string if parsed correctly.

    """
    match = re.search(r'^(\w+)', raw_commit_message)
    if not match:
        if not match.group(1):
            logging.fatal(
                "Couldn't extract the hash from the commit"
            )
        return ''

    return match.group(1)


def verify_branch_up_to_date(  # pylint:disable=R0912, R0911
        desired_branch_name: str,
        target_changelist_number: str,
        forced: bool = False,
        bypass_prompt: bool = False):
    """
    Verify if the desired_branch_name is up to date on git.

    Triggers a pull request and sync with SD if we are to.

    Args:
        desired_branch_name (string): A string containing the name of the
            branch we want to verify if its up to date.
        forced (bool, optional): A flag representing whether we should still
            sync regardless.

    Returns:
        bool: True if we verified that the branch is up to date.
        str: the changelist value detected.

    """
    if not git_fetch():
        logging.info('Could not fetch the last changes in the repository.')
        return False, ''

    if not check_if_remote_set_up_exist():
        logging.info(
            'No remote repository exists. Moving user to latest commit on %s',
            config.get_trunk_branch_name())
        return True, ''

    logging.info(
        'Checking if the branch:\"%s\" is up to date with remote.',
        desired_branch_name)

    remote_branch_name = "{0}/{1}".format(
        config.get_default_remote_name(),
        desired_branch_name)

    local_branch_details = get_details_of_last_commit_for_branch(
        desired_branch_name)
    remote_branch_details = get_details_of_last_commit_for_branch(
        remote_branch_name)

    # Take the information from REMOTE (in case local is behind).
    remote_changelist_number = parse_cl_number_from_raw_commit_message(
        remote_branch_details)
    if not remote_changelist_number:
        logging.error(('Could not extract remote changelist'
                       ' number during branch verification'))
        return False, ''

    local_changelist_number = parse_cl_number_from_raw_commit_message(
        local_branch_details)
    if not local_changelist_number:
        logging.error(('Could not extract local changelist'
                       ' number during branch verification'))
        return False, ''

    logging.debug(('Evaluating if git %s CL matches remote %s.'
                   ' Found %s expected %s'),
                  desired_branch_name,
                  remote_branch_name,
                  local_changelist_number,
                  remote_changelist_number)

    if (int(local_changelist_number) > int(remote_changelist_number)
            and not forced):
        logging.info(("%{desired_branch_name} is ahead of"
                      " remote's version. Skipping update."))
        return True, ''

    if target_changelist_number:
        logging.debug(('Evaluating if the target changelist:'
                       ' %s is newer than existing commit: %s'),
                      local_changelist_number,
                      target_changelist_number)

        if int(local_changelist_number) > int(target_changelist_number):
            logging.fatal(
                ('Invalid operation, attempting to add an older'
                 ' changelist: %s than committed: %s'),
                target_changelist_number,
                local_changelist_number)
            return False, ''

    if not local_branch_details == remote_branch_details:
        logging.error(
            'Local branch is not up to date with remote. Pull required.')

        prompt_message = (f'Branch: \"{desired_branch_name}\" is behind its'
                          ' remote reference, Would you like to Update?')

        user_triggered_update = False

        if not bypass_prompt:
            user_triggered_update =\
             console_utility.request_user_input_with_choices(prompt_message,
                                                             'y/n',
                                                             'y',
                                                             'n')

        if user_triggered_update or bypass_prompt:
            if not pull_latest_branch_version(
                    config.get_trunk_branch_name(),
                    config.get_default_remote_name()):
                logging.fatal(
                    'Could not get the lastest version of the trunk branch.')
                return False, ''

            logging.info(('Git branch is up to date with latest.'
                          ' Notifying that external sync is required.'))
            forced = True
        else:
            logging.error(
                'User triggered interrupt due to cancelled branch switch.')
            return False, ''

    if forced:
        logging.info('Update requested. Syncing external tool to %s',
                     remote_changelist_number)
        return False, remote_changelist_number

    return True, ''


def verify_branch_exists_in_git(target_branch: str, branches: list):
    """
    Verify that the branch exists in the culled list of git branches.

    Args:
        target_branch (str): The name of the branch to check if it exists.
        branches (list): List of branches that are known to us from git's log.

    Returns:
        bool: True if the target_branch exists.

    """
    if (target_branch and (target_branch.lower() not in (
            branchName.lower() for branchName in branches))):
        return False
    return True


def check_if_remote_set_up_exist():
    """
    Check if there is a remote repository set up.

    Do a git remote -v to check if there are any existing remote repositories
        bound to this git instance.

    Returns:
        bool: True if there is a remote repository bound to the repository.

    """
    command = 'git remote -v'
    successfull_command_call,\
        command_results = external_process.trigger_external_subprocess(
            command)
    if successfull_command_call:
        if command_results:
            logging.info(
                'Detected a remote repository bound to this git instance.')
            return True
    return False


def get_git_branch_information():
    """
    Query the names of all the branches in the current git repository.

    Returns:
        list: A list containing all branches known to the respository, both
            local and remote.

    """
    logging.info('Retrieving the Git Repository\'s Branch information.')

    command = 'git branch -a'
    successfull_command_call,\
        command_results = external_process.trigger_external_subprocess(
            command)
    if successfull_command_call:
        branches = re.findall('(\\w.+$)', command_results, re.MULTILINE)
    return branches
